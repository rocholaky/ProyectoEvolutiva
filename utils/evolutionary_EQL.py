import torch
from torch import nn
from network_parts import *
from functools import reduce
from collections import OrderedDict

'''
here we define the the evolutionary EQL network where we can create different networks given a list of blocks generated by an evolutionary algorithm. 

'''

class evol_eql_layer(nn.Module):
    def __init__(self, in_features, block_list, out_features) -> None:
        super().__init__()
        # we define the input and output parameters:
        self.in_F = in_features
        self.out_F = out_features      

        # layer function list: 
        self.b_list = nn.ModuleList(block_list)




    def forward(self, x, device):
        # we create an output to store:
        output = torch.zeros((x.shape[0], self.out_F)).to(device)

        # we itereate through the block list and add the output of each block.
        for block in self.b_list:
            output += block(x)
        # return the output.
        return output

    def to_string(self, threshold=1e-4, input_string=None):
        # name of the variables in the problem
        if input_string is None:
            named_variables = [f"x_{j}" for j in range(self.in_F)]
        else:
            named_variables = [f"{expr}" for expr in input_string]

        block_out = []
        for block in self.b_list:
            block_out.append(block.to_string(named_variables, threshold=threshold))


        result = []
        for i in range(self.out_F):
            res_per_block = []
            for block in block_out:
                res_per_block += [block[i]]
            result.append(res_per_block)
        return result
        
if __name__ == '__main__':
    in_features = 2
    out_features = 1
    n_units = 2
    block_list = [power_Module(in_features, n_units, out_features), 
                    sin_Module(in_features, n_units, out_features)]
    evol_q = evol_eql_layer(in_features, block_list, out_features)
    print(list(evol_q.parameters()))