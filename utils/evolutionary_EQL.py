import torch
from torch import nn
from network_parts import *
from functools import reduce

'''
here we define the the evolutionary EQL network where we can create differente networks given a list of blocks generated by an evolutionary algorithm. 

'''

class evol_eql_layer(nn.Module):
    def __init__(self, in_features, block_list, out_features) -> None:
        super(evol_eql_layer).__init__()
        # we define the input and output parameters:
        self.in_F = in_features
        self.out_F = out_features

        # layer function list: 
        self.b_list = block_list


    def forward(self, x):
        # we create an output to store: 
        output = torch.zeros_like(x.shape[0], self.out_F)
        # we itereate through the block list and add the output of each block. 
        for block in self.b_list:
            output += block(x)
        # return the output.
        return output

    def to_string(self, threshold=1e-4, input_string=None):
        # name of the variables in the problem
        if input_string is None:
            named_variables = [f"x_{j}" for j in range(self.in_F)]
        else:
            named_variables = [f"{expr}" for expr in input_string]

        block_out = []
        for block in self.b_list:
            block_out.append(block.to_string(named_variables, threshold=threshold))


        result = [reduce(lambda x, y: x+y, [b_out for b_out in block_out])
                  for j in range(self.out_F)]
        return result
        
if __name__ == '__main__':
    in_features = 2
    out_features = 1
    n_units = 2
    block_list = [power_Module(in_features, n_units, out_features), 
                    sin_Module(in_features, n_units, out_features)]
    evol_q = evol_eql_layer(in_features, block_list, out_features)
    print(evol_q.to_string())